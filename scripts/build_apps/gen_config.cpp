/* SPDX-License-Identifier: BSD-2-Clause */

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <regex>
#include <filesystem>

using namespace std;
using namespace filesystem;

struct gen_data {
   path ro_config_vars_file;
   vector<string> modules;
   map<string, vector<string>> option_categories;
};

static void
gen_includes(ostream &out, const gen_data &data)
{
   out << "/* This file is AUTO-GENERATED by the gen_config tool */\n";
   out << "\n";
   out << "#include \"" + string(data.ro_config_vars_file) + "\"\n";
   out << "\n";

   for (const string &mod: data.modules) {
      out << "#include <tilck_gen_headers/mod_" << mod << ".h>\n";
   }

   out << "\n";
   out << "static void sysfs_fail_to_register_obj(const char *name);\n";
   out << "\n";
}

static void
gen_globals(ostream &out, const gen_data &data)
{
   out << "/* modules */\n";
   for (const string &mod : data.modules) {
      out << "DEF_STATIC_CONF_RO(BOOL, " << mod << ", MOD_" << mod << ");\n";
   }
   out << "\n";

   for (auto &[cat, opts] : data.option_categories) {

      out << "DEF_STATIC_SYSOBJ_TYPE(\n";
      out << "   type_" << cat << ",\n";

      for (const string &name : opts) {
         out << "   &prop_" << name << ",\n";
      }

      out << "   NULL\n";
      out << ");\n";
      out << "\n";

      out << "DEF_STATIC_SYSOBJ(\n";
      out << "   obj_" << cat << ",\n";
      out << "   &type_" << cat << ",\n";
      out << "   NULL /* hooks */,\n";
      for (const string &name : opts) {
         out << "   &conf_" << name << ",\n";
      }
      out << ");\n";
      out << "\n";
   }
}

static void
gen_functions(ostream &out, const gen_data &data)
{
   out << R"(
void
sysfs_create_config_obj(void)
{
   struct sysobj *root = &sysfs_root_obj;
   const char *name;

)";

   for (auto &[c, opts] : data.option_categories) {
      out << "   name = \"" << c << "\";\n";
      out << "   if (sysfs_register_obj(NULL, root, name, &obj_" << c << "))\n";
      out << "      goto fail;\n\n";
   }

out << R"(
   return; /* success */

fail:
   sysfs_fail_to_register_obj(name);
}
)";

}

static void
get_modules_list(gen_data &data, const path &projRoot)
{
   const path modulesDir = projRoot / "modules";

   /* Find all the 1st-level sub-directories of modules/ */
   for (auto &entry : directory_iterator(modulesDir)) {
      if (entry.is_directory()) {
         const string &filename = entry.path().filename();
         data.modules.push_back(filename);
         data.option_categories["modules"].push_back(filename);
      }
   }
}

static void
get_all_options(gen_data &data)
{
   const regex reCategory(R"(/\* (\w+) \*/)");
   const regex reOption(R"(DEF_STATIC_CONF_RO\((\w+),\s+(\w+),\s+(.+)\);)");

   string category;
   string line;
   smatch m;

   /*
    * Parse the modules/sysfs/ro_config_vars.h file in order to find all the
    * sysfs conf objects, one for each Tilck option.
    */
   ifstream configFile(data.ro_config_vars_file);

   while (!configFile.eof()) {

      getline(configFile, line);

      if (regex_match(line, m, reCategory)) {
         category = m[1];
         continue;
      }

      if (regex_match(line, m, reOption)) {

         if (category.empty()) {
            cerr << "No category found before the following line:" << endl;
            cerr << line << endl;
            abort();
         }

         const string &opt_variable = m[2];
         data.option_categories[category].push_back(opt_variable);
      }
   }
}

int main(int argc, char **argv)
{
   if (argc < 3) {
      cerr << "Syntax: " << argv[0] << " <Tilck source dir> <Output file>\n";
      return 1;
   }

   const path projRoot = path(argv[1]);
   const path outputFile = path(argv[2]);
   gen_data data;

   data.ro_config_vars_file =
      projRoot / "modules" / "sysfs" / "ro_config_vars.h";

   get_modules_list(data, projRoot);
   get_all_options(data);

   ofstream out(outputFile);
   gen_includes(out, data);
   gen_globals(out, data);
   gen_functions(out, data);
   return 0;
}
