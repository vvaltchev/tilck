#!/usr/bin/env bash
# SPDX-License-Identifier: BSD-2-Clause

# ---------------------------------------------------------------
# NOTE
#
# This "script" is NOT meant to be executed directly.
# It is included as a source file by scripts/build_toolchain.
#
# ---------------------------------------------------------------


function custom_gcc_cross_tc_internal {


   local arch="$1"
   local os_suffix=""
   local gh="https://github.com"
   local url="$gh/vvaltchev/musl-cross-make/releases/download/3635262e452"
   local tarname=""
   local url_target=""
   local url_host=""
   local varName
   local ver
   local ver_
   local n

   case $arch in
      i386) url_target="i386";;
      x86_64) url_target="x86_64";;
      aarch64) url_target="aarch64";;
      riscv64) url_target="riscv64";;
      *) echo "TARGET $arch not supported by the CUSTOM GCC TC"; exit 1;;
   esac

   case $HOST_ARCH in
      i386) url_host="i386";;
      x86_64) url_host="x86_64";;
      aarch64) url_host="aarch64";;
      *) echo "HOST $HOST_ARCH not supported by the CUSTOM GCC TC"; exit 1;;
   esac

   if [[ "$OS" == "FreeBSD" ]]; then
      os_suffix="-freebsd"
   fi

   varName="${arch}_GCC_TC_VER"
   ver="${!varName}"
   varName="${arch}_GCC_TC_VER_"
   ver_="${!varName}"
   varName="${arch}_ARCH_GCC_TC"
   arch_gcc="${!varName}"
   dir="gcc_${ver_}_${arch}_musl"

   if [ -d "$dir" ]; then
      return
   fi

   tarname="${url_target}-musl-${VER_MUSL}"
   tarname="${tarname}-gcc-${ver}"
   tarname="${tarname}-${url_host}${os_suffix}.tar.bz2"

   download_file_in_cache "$url" "$tarname"
   extract_cachefile_tar_bz $tarname --

   pushd gcc_${ver_}_${arch}_musl/bin
   for x in ${arch_gcc}-linux-musl-*; do
      if [[ -f "$x" ]]; then
         n="$(sed s/musl-// <<<"$x")"
         if [[ -L "$x" ]]; then
            # Symlink. Must fix the destination as well.
            dest="$(readlink "$x")"
            dest="$(sed s/musl-// <<<"$dest")"
            rm "$x"
            ln -s "$dest" "$n"
         else
            # Regular file: just rename it.
            mv "$x" "$n"
         fi
      fi
   done
   popd
   rm -f ${arch_gcc}-linux-cc
}

function custom_gcc_cross_tc {

   pushd $HOST_ARCH_DIR_SYS

   # Download the TC for the current *host* architecture: that's necessary
   # so that we don't depend on the GCC version available on the system.
   custom_gcc_cross_tc_internal "$HOST_ARCH"

   if [[ $ARCH == i386 || $ARCH == x86_64 ]]; then

      # Always download the i386 toolchain to build the legacy bootloader
      custom_gcc_cross_tc_internal "i386"

      # Always download the x86_64 toolchain to build the 64-bit UEFI bootloader
      custom_gcc_cross_tc_internal "x86_64"

   else

      # General case: just download the arch-specific toolchain
      custom_gcc_cross_tc_internal "$ARCH"
   fi

   popd
}


# ---------------------------------------------------------------------------

# $1 = arch
# $2 = libc
function get_gcc_tc_installed_status_int {

   local arch_list=""
   local pfx

   pfx="${1}_GCC_NAME_PFX"
   pfx=${!pfx}

   if [ -d $HOST_ARCH_DIR_SYS/${pfx}_$2 ]; then
      echo "installed host_$HOST_ARCH"
   fi
}

function define_all_gcc_tc_funcs {

   for libc in musl; do
      for arch in ${ALL_ARCH_LIST[@]}; do

         local name="download_gcc_${libc}_${arch}"
         local body="get_gcc_tc_installed_status_int $arch $libc;"

         all_funcs_list+=($name)
         eval "function $name { download_gcc_tc_internal $arch $libc; }"
         eval "function ${name}_installed_status { $body }"
      done
   done
}

define_all_gcc_tc_funcs

